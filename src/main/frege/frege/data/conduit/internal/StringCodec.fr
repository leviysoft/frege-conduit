module frege.data.conduit.internal.StringCodec where

import frege.control.monad.trans.MonadTrans (lift)
import frege.data.ByteString as BS (ByteString)
import frege.data.Conduit (ConduitT, await, leftover, yield)

data Charset = pure native java.nio.charset.Charset where
  native newDecoder :: Charset -> STMutable s CharsetDecoder

pure native utf8 java.nio.charset.StandardCharsets.UTF_8 :: Charset

native getBytes :: String -> Charset -> STMutable s (JArray Byte)
pure native newString new :: JArray Byte -> Int -> Int -> Charset -> String

encodeUtf8 :: String -> ByteString
encodeUtf8 s = ST.run (BS.unsafeFreeze =<< getBytes s utf8)

decodeUtf8 :: ByteString -> String
decodeUtf8 (ByteString{payload, offset, length}) =
    newString payload offset length utf8

data CoderResult = pure native java.nio.charset.CoderResult where
  pure native overflow  java.nio.charset.CoderResult.OVERFLOW  :: CoderResult
  pure native underflow java.nio.charset.CoderResult.UNDERFLOW :: CoderResult
  pure native (==) equals :: CoderResult -> CoderResult -> Bool
  pure native hashCode :: CoderResult -> Int

instance Eq CoderResult

data CharsetDecoder = native java.nio.charset.CharsetDecoder where
  native decode :: Mutable s CharsetDecoder -> Mutable s ByteBuffer -> Mutable s CharBuffer -> Bool -> ST s CoderResult
  native flush :: Mutable s CharsetDecoder -> Mutable s CharBuffer -> ST s CoderResult

data ByteBuffer = native java.nio.ByteBuffer where
  native allocate java.nio.ByteBuffer.allocate :: Int -> STMutable s ByteBuffer
  native put :: Mutable s ByteBuffer -> ArrayOf s Byte -> Int -> Int -> STMutable s ByteBuffer

data CharBuffer = native java.nio.CharBuffer where
  native allocate java.nio.CharBuffer.allocate :: Int -> STMutable s CharBuffer
  native put :: Mutable s CharBuffer -> ArrayOf s Char -> Int -> Int -> STMutable s CharBuffer
  native toString :: Mutable s CharBuffer -> ST s String

-- decodeUtf8Streaming :: Monad m => ConduitT ByteString String m ()
decodeUtf8Streaming :: ConduitT ByteString String (ST s) ()
decodeUtf8Streaming = do
    -- the implementation abuses the fact that any Monad, including pure ones,
    -- is sequentially evaluated.
    -- better ideas are welcome!
    decoder <- lift $ utf8.newDecoder
    byteBuf <- lift $ ByteBuffer.allocate 1024
    charBuf <- lift $ CharBuffer.allocate 1024
    let loop cr
          | cr == CoderResult.underflow = do
            mbs <- await
            case mbs of
              Just bs
                | BS.length bs > 1024 -> do
                    let (first, more) = BS.splitAt 1024 bs
                    leftover more
                    leftover first
                    loop cr
                | otherwise -> do
                    lift $ byteBuf.put (mutable bs.payload) bs.offset bs.length
                    cr' <- lift $ decoder.decode byteBuf charBuf False
                    loop cr'
              Nothing -> do
                  lift $ decoder.flush charBuf
                  yield =<< lift (charBuf.toString)
          | otherwise {- overflow -} = do
            yield =<< lift (charBuf.toString)
            cr' <- lift $ decoder.decode byteBuf charBuf False
            loop cr'
    loop CoderResult.underflow
